#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include <set>
#include <numeric>
#include <cstring>
#include <cstdlib>
#include "neb_interpolator.h"

struct Atom {
    std::string element;
    double x, y, z;
};

class MoleculeAnalyzer {
private:
    std::vector<Atom> atoms;
    std::string currentFile;
    bool useBohr = false; // false = Angstrom, true = Bohr
    const double BOHR_TO_ANG = 0.529177211;
    
    // Parse Gview-style index string (supports both full-width and half-width commas)
    std::set<int> parseIndices(const std::string& str) {
        std::set<int> indices;
        std::string cleaned = str;
        
        // Replace full-width comma with half-width
        size_t pos = 0;
        while ((pos = cleaned.find("ï¼Œ")) != std::string::npos) {
            cleaned.replace(pos, 3, ","); // Full-width comma is 3 bytes
        }
        
        std::stringstream ss(cleaned);
        std::string token;
        
        while (std::getline(ss, token, ',')) {
            // Remove whitespace
            token.erase(std::remove_if(token.begin(), token.end(), ::isspace), token.end());
            
            size_t dashPos = token.find('-');
            if (dashPos != std::string::npos) {
                // Range format: start-end
                int start = std::stoi(token.substr(0, dashPos));
                int end = std::stoi(token.substr(dashPos + 1));
                for (int i = start; i <= end; i++) {
                    if (i > 0 && i <= atoms.size()) {
                        indices.insert(i - 1); // Convert to 0-based
                    }
                }
            } else {
                // Single number
                int idx = std::stoi(token);
                if (idx > 0 && idx <= atoms.size()) {
                    indices.insert(idx - 1); // Convert to 0-based
                }
            }
        }
        
        return indices;
    }
    
    double getDistance(const Atom& a1, const Atom& a2) {
        double dx = a2.x - a1.x;
        double dy = a2.y - a1.y;
        double dz = a2.z - a1.z;
        double dist = std::sqrt(dx*dx + dy*dy + dz*dz);
        return useBohr ? dist / BOHR_TO_ANG : dist;
    }
    
    void getVector(const Atom& a1, const Atom& a2, double& vx, double& vy, double& vz) {
        vx = a2.x - a1.x;
        vy = a2.y - a1.y;
        vz = a2.z - a1.z;
        if (useBohr) {
            vx /= BOHR_TO_ANG;
            vy /= BOHR_TO_ANG;
            vz /= BOHR_TO_ANG;
        }
    }
    
    double dotProduct(double x1, double y1, double z1, double x2, double y2, double z2) {
        return x1*x2 + y1*y2 + z1*z2;
    }
    
    void crossProduct(double x1, double y1, double z1, double x2, double y2, double z2,
                      double& rx, double& ry, double& rz) {
        rx = y1*z2 - z1*y2;
        ry = z1*x2 - x1*z2;
        rz = x1*y2 - y1*x2;
    }
    
    void normalize(double& x, double& y, double& z) {
        double mag = std::sqrt(x*x + y*y + z*z);
        if (mag > 1e-10) {
            x /= mag; y /= mag; z /= mag;
        }
    }
    
public:
    bool loadXYZ(const std::string& filename) {
        std::ifstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Error: Cannot open file " << filename << std::endl;
            return false;
        }
        
        atoms.clear();
        int natoms;
        file >> natoms;
        file.ignore(); // Skip rest of first line
        
        std::string comment;
        std::getline(file, comment); // Skip comment line
        
        for (int i = 0; i < natoms; i++) {
            Atom atom;
            file >> atom.element >> atom.x >> atom.y >> atom.z;
            atoms.push_back(atom);
        }
        
        currentFile = filename;
        file.close();
        return true;
    }
    
    void saveXYZ(const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Error: Cannot create file " << filename << std::endl;
            return;
        }
        
        file << atoms.size() << std::endl;
        file << "Generated by Molecular Geometry Analyzer" << std::endl;
        
        for (const auto& atom : atoms) {
            file << std::setw(4) << atom.element 
                 << std::fixed << std::setprecision(6)
                 << std::setw(12) << atom.x
                 << std::setw(12) << atom.y
                 << std::setw(12) << atom.z << std::endl;
        }
        
        file.close();
        std::cout << "File saved: " << filename << std::endl;
    }
    
    void printXYZ() {
        std::cout << atoms.size() << std::endl;
        std::cout << "Current structure" << std::endl;
        for (const auto& atom : atoms) {
            std::cout << std::setw(4) << atom.element 
                     << std::fixed << std::setprecision(6)
                     << std::setw(12) << atom.x
                     << std::setw(12) << atom.y
                     << std::setw(12) << atom.z << std::endl;
        }
    }
    
    // Function -1: Print current structure to screen
    void printCurrentStructure() {
        printXYZ();
    }
    
    // Function 13: Align with second XYZ file using calc_rmsd_xyz
    void alignWithSecondXYZ() {
        std::cout << "Enter reference XYZ filename to align with: ";
        std::string refFile;
        std::getline(std::cin, refFile);
        
        // Check if reference file exists
        std::ifstream check(refFile);
        if (!check.is_open()) {
            std::cerr << "Error: Cannot open reference file " << refFile << std::endl;
            return;
        }
        check.close();
        
        // Save current structure to temp file
        std::string tempFile = "temp_mobile.xyz";
        saveXYZ(tempFile);
        
        // Call calc_rmsd_xyz program
        std::string command = "./calc_rmsd_xyz " + refFile + " " + tempFile;
        std::cout << "Running alignment: " << command << std::endl;
        
        int result = system(command.c_str());
        
        if (result != 0) {
            std::cerr << "Error: Alignment failed with exit code " << result << std::endl;
            system(("rm -f " + tempFile).c_str());
            return;
        }
        
        // Load aligned structure back into memory
        std::string alignedFile = "temp_mobile_new.xyz";
        if (!loadXYZ(alignedFile)) {
            std::cerr << "Error: Cannot load aligned structure" << std::endl;
            system(("rm -f " + tempFile).c_str());
            return;
        }
        
        std::cout << "Structure aligned successfully and loaded into memory." << std::endl;
        
        // Clean up temp files
        system(("rm -f " + tempFile).c_str());
        system(("rm -f " + alignedFile).c_str());
    }
    
    // Function 14: NEB interpolation with second XYZ file
    void performNEBWithSecondXYZ() {
        std::cout << "Enter final XYZ filename for NEB interpolation: ";
        std::string finalFile;
        std::getline(std::cin, finalFile);
        
        // Check if final file exists
        std::ifstream check(finalFile);
        if (!check.is_open()) {
            std::cerr << "Error: Cannot open final file " << finalFile << std::endl;
            return;
        }
        check.close();
        
        std::cout << "Enter number of intermediate images (default 5): ";
        std::string input;
        std::getline(std::cin, input);
        int numImages = input.empty() ? 5 : std::stoi(input);
        
        std::cout << "Use NEB (n) or LIIC (l) method? (default n): ";
        std::getline(std::cin, input);
        bool useNEB = (input.empty() || input == "n" || input == "N");
        
        std::cout << "Enter output prefix (default: neb_): ";
        std::string prefix;
        std::getline(std::cin, prefix);
        if (prefix.empty()) prefix = "neb_";
        
        // Create NEB interpolator
        SimpleNEBInterpolator interpolator(numImages);
        
        // Convert current atoms to NEB format
        std::vector<NEBAtom> nebAtoms;
        for (const auto& atom : atoms) {
            nebAtoms.push_back(NEBAtom(atom.element, atom.x, atom.y, atom.z));
        }
        
        // Set initial structure from memory
        interpolator.setInitialFromMemory(nebAtoms);
        
        // Set final structure from file
        if (!interpolator.setFinalFromFile(finalFile)) {
            std::cerr << "Error: Failed to set up NEB interpolation" << std::endl;
            return;
        }
        
        // Perform interpolation
        if (useNEB) {
            interpolator.performNEB();
        } else {
            interpolator.performLIIC();
        }
        
        // Write results
        if (!interpolator.writeResults(prefix)) {
            std::cerr << "Error: Failed to write NEB results" << std::endl;
            return;
        }
        
        std::cout << "NEB interpolation completed successfully!" << std::endl;
    }
    
    // Function 1: Calculate distance and vector between 2 atoms
    void calculateDistanceVector() {
        std::cout << "Enter indices of 2 atoms (Gview format, e.g., 1,3): ";
        std::string input;
        std::getline(std::cin, input);
        
        auto indices = parseIndices(input);
        if (indices.size() != 2) {
            std::cout << "Error: Please select exactly 2 atoms." << std::endl;
            return;
        }
        
        std::vector<int> idx(indices.begin(), indices.end());
        double dist = getDistance(atoms[idx[0]], atoms[idx[1]]);
        
        double vx, vy, vz;
        getVector(atoms[idx[0]], atoms[idx[1]], vx, vy, vz);
        
        std::string unit = useBohr ? "Bohr" : "Angstrom";
        std::cout << "\nDistance: " << std::fixed << std::setprecision(6) 
                  << dist << " " << unit << std::endl;
        std::cout << "Vector: (" << vx << ", " << vy << ", " << vz << ") " << unit << std::endl;
    }
    
    // Function 2: Swap two atoms
    void swapAtoms(bool commandLine = false) {
        if (!commandLine) {
            std::cout << "Enter indices of 2 atoms to swap (Gview format): ";
            std::string input;
            std::getline(std::cin, input);
            
            auto indices = parseIndices(input);
            if (indices.size() != 2) {
                std::cout << "Error: Please select exactly 2 atoms." << std::endl;
                return;
            }
            
            std::vector<int> idx(indices.begin(), indices.end());
            std::swap(atoms[idx[0]], atoms[idx[1]]);
            std::cout << "Atoms swapped successfully." << std::endl;
        }
    }
    
    // Function 3: Calculate bond angle and plane normal
    void calculateBondAngle() {
        std::cout << "Enter indices of 3 atoms (Gview format): ";
        std::string input;
        std::getline(std::cin, input);
        
        auto indices = parseIndices(input);
        if (indices.size() != 3) {
            std::cout << "Error: Please select exactly 3 atoms." << std::endl;
            return;
        }
        
        std::vector<int> idx(indices.begin(), indices.end());
        
        // Calculate vectors
        double v1x = atoms[idx[0]].x - atoms[idx[1]].x;
        double v1y = atoms[idx[0]].y - atoms[idx[1]].y;
        double v1z = atoms[idx[0]].z - atoms[idx[1]].z;
        
        double v2x = atoms[idx[2]].x - atoms[idx[1]].x;
        double v2y = atoms[idx[2]].y - atoms[idx[1]].y;
        double v2z = atoms[idx[2]].z - atoms[idx[1]].z;
        
        // Calculate angle
        double dot = dotProduct(v1x, v1y, v1z, v2x, v2y, v2z);
        double mag1 = std::sqrt(v1x*v1x + v1y*v1y + v1z*v1z);
        double mag2 = std::sqrt(v2x*v2x + v2y*v2y + v2z*v2z);
        double angle = std::acos(dot / (mag1 * mag2)) * 180.0 / M_PI;
        
        // Calculate plane normal
        double nx, ny, nz;
        crossProduct(v1x, v1y, v1z, v2x, v2y, v2z, nx, ny, nz);
        normalize(nx, ny, nz);
        
        std::cout << "\nBond angle: " << std::fixed << std::setprecision(2) 
                  << angle << " degrees" << std::endl;
        std::cout << "Plane normal vector: (" << std::setprecision(6) 
                  << nx << ", " << ny << ", " << nz << ")" << std::endl;
    }
    
    // Function 4: Calculate angle between two planes
    void calculatePlaneAngle() {
        std::cout << "Enter indices of first 3 atoms (Gview format): ";
        std::string input1;
        std::getline(std::cin, input1);
        
        auto indices1 = parseIndices(input1);
        if (indices1.size() != 3) {
            std::cout << "Error: Please select exactly 3 atoms for first plane." << std::endl;
            return;
        }
        
        std::cout << "Enter indices of second 3 atoms (Gview format): ";
        std::string input2;
        std::getline(std::cin, input2);
        
        auto indices2 = parseIndices(input2);
        if (indices2.size() != 3) {
            std::cout << "Error: Please select exactly 3 atoms for second plane." << std::endl;
            return;
        }
        
        std::vector<int> idx1(indices1.begin(), indices1.end());
        std::vector<int> idx2(indices2.begin(), indices2.end());
        
        // Calculate normal for plane 1
        double v1x = atoms[idx1[1]].x - atoms[idx1[0]].x;
        double v1y = atoms[idx1[1]].y - atoms[idx1[0]].y;
        double v1z = atoms[idx1[1]].z - atoms[idx1[0]].z;
        
        double v2x = atoms[idx1[2]].x - atoms[idx1[0]].x;
        double v2y = atoms[idx1[2]].y - atoms[idx1[0]].y;
        double v2z = atoms[idx1[2]].z - atoms[idx1[0]].z;
        
        double n1x, n1y, n1z;
        crossProduct(v1x, v1y, v1z, v2x, v2y, v2z, n1x, n1y, n1z);
        normalize(n1x, n1y, n1z);
        
        // Calculate normal for plane 2
        v1x = atoms[idx2[1]].x - atoms[idx2[0]].x;
        v1y = atoms[idx2[1]].y - atoms[idx2[0]].y;
        v1z = atoms[idx2[1]].z - atoms[idx2[0]].z;
        
        v2x = atoms[idx2[2]].x - atoms[idx2[0]].x;
        v2y = atoms[idx2[2]].y - atoms[idx2[0]].y;
        v2z = atoms[idx2[2]].z - atoms[idx2[0]].z;
        
        double n2x, n2y, n2z;
        crossProduct(v1x, v1y, v1z, v2x, v2y, v2z, n2x, n2y, n2z);
        normalize(n2x, n2y, n2z);
        
        // Calculate angle between normals
        double dot = dotProduct(n1x, n1y, n1z, n2x, n2y, n2z);
        double angle = std::acos(std::min(1.0, std::max(-1.0, dot))) * 180.0 / M_PI;
        
        std::cout << "\nAngle between planes: " << std::fixed << std::setprecision(2) 
                  << angle << " degrees" << std::endl;
    }
    
    // Function 5: Mirror molecule through plane
    void mirrorThroughPlane(bool commandLine = false) {
        if (!commandLine) {
            std::cout << "Enter indices of 3 atoms defining the plane (Gview format): ";
            std::string input;
            std::getline(std::cin, input);
            
            auto indices = parseIndices(input);
            if (indices.size() != 3) {
                std::cout << "Error: Please select exactly 3 atoms." << std::endl;
                return;
            }
            
            std::vector<int> idx(indices.begin(), indices.end());
            
            // Calculate plane equation ax + by + cz + d = 0
            double v1x = atoms[idx[1]].x - atoms[idx[0]].x;
            double v1y = atoms[idx[1]].y - atoms[idx[0]].y;
            double v1z = atoms[idx[1]].z - atoms[idx[0]].z;
            
            double v2x = atoms[idx[2]].x - atoms[idx[0]].x;
            double v2y = atoms[idx[2]].y - atoms[idx[0]].y;
            double v2z = atoms[idx[2]].z - atoms[idx[0]].z;
            
            double a, b, c;
            crossProduct(v1x, v1y, v1z, v2x, v2y, v2z, a, b, c);
            normalize(a, b, c);
            
            double d = -(a * atoms[idx[0]].x + b * atoms[idx[0]].y + c * atoms[idx[0]].z);
            
            // Mirror all atoms
            for (auto& atom : atoms) {
                double dist = a * atom.x + b * atom.y + c * atom.z + d;
                atom.x = atom.x - 2 * dist * a;
                atom.y = atom.y - 2 * dist * b;
                atom.z = atom.z - 2 * dist * c;
            }
            
            std::cout << "Molecule mirrored successfully." << std::endl;
        }
    }
    
    // Function 6: Calculate dihedral angle
    void calculateDihedralAngle() {
        std::cout << "Enter indices of 4 atoms (Gview format): ";
        std::string input;
        std::getline(std::cin, input);
        
        auto indices = parseIndices(input);
        if (indices.size() != 4) {
            std::cout << "Error: Please select exactly 4 atoms." << std::endl;
            return;
        }
        
        std::vector<int> idx(indices.begin(), indices.end());
        
        // Vectors
        double v1x = atoms[idx[1]].x - atoms[idx[0]].x;
        double v1y = atoms[idx[1]].y - atoms[idx[0]].y;
        double v1z = atoms[idx[1]].z - atoms[idx[0]].z;
        
        double v2x = atoms[idx[2]].x - atoms[idx[1]].x;
        double v2y = atoms[idx[2]].y - atoms[idx[1]].y;
        double v2z = atoms[idx[2]].z - atoms[idx[1]].z;
        
        double v3x = atoms[idx[3]].x - atoms[idx[2]].x;
        double v3y = atoms[idx[3]].y - atoms[idx[2]].y;
        double v3z = atoms[idx[3]].z - atoms[idx[2]].z;
        
        // Normal vectors
        double n1x, n1y, n1z;
        crossProduct(v1x, v1y, v1z, v2x, v2y, v2z, n1x, n1y, n1z);
        
        double n2x, n2y, n2z;
        crossProduct(v2x, v2y, v2z, v3x, v3y, v3z, n2x, n2y, n2z);
        
        // Calculate dihedral angle
        double x = dotProduct(n1x, n1y, n1z, n2x, n2y, n2z);
        double y = std::sqrt(n1x*n1x + n1y*n1y + n1z*n1z) * std::sqrt(n2x*n2x + n2y*n2y + n2z*n2z);
        
        double angle = std::acos(x / y) * 180.0 / M_PI;
        
        // Determine sign
        double cx, cy, cz;
        crossProduct(n1x, n1y, n1z, n2x, n2y, n2z, cx, cy, cz);
        if (dotProduct(cx, cy, cz, v2x, v2y, v2z) < 0) {
            angle = -angle;
        }
        
        std::cout << "\nDihedral angle: " << std::fixed << std::setprecision(2) 
                  << angle << " degrees" << std::endl;
    }
    
    // Function 7: Calculate geometric center
    void calculateGeometricCenter() {
        std::cout << "Enter indices of atoms (Gview format): ";
        std::string input;
        std::getline(std::cin, input);
        
        auto indices = parseIndices(input);
        if (indices.empty()) {
            std::cout << "Error: Please select at least one atom." << std::endl;
            return;
        }
        
        double cx = 0, cy = 0, cz = 0;
        for (int idx : indices) {
            cx += atoms[idx].x;
            cy += atoms[idx].y;
            cz += atoms[idx].z;
        }
        
        cx /= indices.size();
        cy /= indices.size();
        cz /= indices.size();
        
        if (useBohr) {
            cx /= BOHR_TO_ANG;
            cy /= BOHR_TO_ANG;
            cz /= BOHR_TO_ANG;
        }
        
        std::string unit = useBohr ? "Bohr" : "Angstrom";
        std::cout << "\nGeometric center: (" << std::fixed << std::setprecision(6) 
                  << cx << ", " << cy << ", " << cz << ") " << unit << std::endl;
    }
    
    // Function 8: Export selected atoms
    void exportSelectedAtoms() {
        std::cout << "Enter indices of atoms to export (Gview format): ";
        std::string input;
        std::getline(std::cin, input);
        
        auto indices = parseIndices(input);
        if (indices.empty()) {
            std::cout << "Error: Please select at least one atom." << std::endl;
            return;
        }
        
        std::cout << "Enter output filename: ";
        std::string filename;
        std::getline(std::cin, filename);
        
        std::ofstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Error: Cannot create file " << filename << std::endl;
            return;
        }
        
        file << indices.size() << std::endl;
        file << "Selected atoms from " << currentFile << std::endl;
        
        for (int idx : indices) {
            file << std::setw(4) << atoms[idx].element 
                 << std::fixed << std::setprecision(6)
                 << std::setw(12) << atoms[idx].x
                 << std::setw(12) << atoms[idx].y
                 << std::setw(12) << atoms[idx].z << std::endl;
        }
        
        file.close();
        std::cout << "File saved: " << filename << std::endl;
    }
    
    // Function 9: Find atoms within radius
    void findAtomsWithinRadius() {
        std::cout << "Enter index of central atom: ";
        std::string input;
        std::getline(std::cin, input);
        
        auto indices = parseIndices(input);
        if (indices.size() != 1) {
            std::cout << "Error: Please select exactly 1 atom." << std::endl;
            return;
        }
        
        int centerIdx = *indices.begin();
        
        std::cout << "Enter radius (in " << (useBohr ? "Bohr" : "Angstrom") << "): ";
        double radius;
        std::cin >> radius;
        std::cin.ignore();
        
        if (useBohr) {
            radius *= BOHR_TO_ANG; // Convert to Angstrom for calculation
        }
        
        std::set<int> nearbyAtoms;
        for (int i = 0; i < atoms.size(); i++) {
            if (i != centerIdx) {
                double dist = std::sqrt(
                    std::pow(atoms[i].x - atoms[centerIdx].x, 2) +
                    std::pow(atoms[i].y - atoms[centerIdx].y, 2) +
                    std::pow(atoms[i].z - atoms[centerIdx].z, 2)
                );
                
                if (dist <= radius) {
                    nearbyAtoms.insert(i);
                }
            }
        }
        
        if (nearbyAtoms.empty()) {
            std::cout << "No atoms found within radius." << std::endl;
            return;
        }
        
        // Output Gview-style indices
        std::cout << "\nAtoms within radius (Gview indices): ";
        bool first = true;
        int start = -1, end = -1;
        for (int idx : nearbyAtoms) {
            if (start == -1) {
                start = end = idx + 1; // Convert to 1-based
            } else if (idx + 1 == end + 1) {
                end = idx + 1;
            } else {
                if (!first) std::cout << ",";
                if (start == end) {
                    std::cout << start;
                } else if (end == start + 1) {
                    std::cout << start << "," << end;
                } else {
                    std::cout << start << "-" << end;
                }
                first = false;
                start = end = idx + 1;
            }
        }
        if (!first) std::cout << ",";
        if (start == end) {
            std::cout << start;
        } else if (end == start + 1) {
            std::cout << start << "," << end;
        } else {
            std::cout << start << "-" << end;
        }
        std::cout << std::endl;
        
        // Save to file
        std::cout << "Enter output filename: ";
        std::string filename;
        std::getline(std::cin, filename);
        
        std::ofstream file(filename);
        file << nearbyAtoms.size() + 1 << std::endl; // +1 for center atom
        file << "Atoms within " << radius << " Angstrom of atom " << (centerIdx + 1) << std::endl;
        
        // Write center atom first
        file << std::setw(4) << atoms[centerIdx].element 
             << std::fixed << std::setprecision(6)
             << std::setw(12) << atoms[centerIdx].x
             << std::setw(12) << atoms[centerIdx].y
             << std::setw(12) << atoms[centerIdx].z << std::endl;
        
        // Write nearby atoms
        for (int idx : nearbyAtoms) {
            file << std::setw(4) << atoms[idx].element 
                 << std::fixed << std::setprecision(6)
                 << std::setw(12) << atoms[idx].x
                 << std::setw(12) << atoms[idx].y
                 << std::setw(12) << atoms[idx].z << std::endl;
        }
        
        file.close();
        std::cout << "File saved: " << filename << std::endl;
    }
    
    // Function 10: Export current structure
    void exportCurrentStructure() {
        std::cout << "Enter output filename: ";
        std::string filename;
        std::getline(std::cin, filename);
        saveXYZ(filename);
    }
    
    // Function 11: Load new XYZ file
    void loadNewFile() {
        std::cout << "Enter XYZ filename to load: ";
        std::string filename;
        std::getline(std::cin, filename);
        
        if (loadXYZ(filename)) {
            std::cout << "File loaded successfully. " << atoms.size() << " atoms." << std::endl;
        }
    }
    
    // Function 12: Toggle units
    void toggleUnits() {
        useBohr = !useBohr;
        std::cout << "Units changed to: " << (useBohr ? "Bohr" : "Angstrom") << std::endl;
    }
    
    void showMenu() {
        std::cout << "\n========== Molecular Geometry Analyzer ==========" << std::endl;
        std::cout << "Current file: " << currentFile << std::endl;
        std::cout << "Atoms loaded: " << atoms.size() << std::endl;
        std::cout << "Current units: " << (useBohr ? "Bohr" : "Angstrom") << std::endl;
        std::cout << "\n-1. Print current structure to screen" << std::endl;
        std::cout << "1.  Calculate distance and vector between 2 atoms" << std::endl;
        std::cout << "2.  Swap two atoms" << std::endl;
        std::cout << "3.  Calculate bond angle and plane normal" << std::endl;
        std::cout << "4.  Calculate angle between two planes" << std::endl;
        std::cout << "5.  Mirror molecule through plane" << std::endl;
        std::cout << "6.  Calculate dihedral angle" << std::endl;
        std::cout << "7.  Calculate geometric center" << std::endl;
        std::cout << "8.  Export selected atoms to XYZ" << std::endl;
        std::cout << "9.  Find atoms within radius" << std::endl;
        std::cout << "10. Export current structure to XYZ" << std::endl;
        std::cout << "11. Load new XYZ file" << std::endl;
        std::cout << "12. Toggle units (Bohr/Angstrom)" << std::endl;
        std::cout << "13. Align with second XYZ file (RMSD)" << std::endl;
        std::cout << "14. NEB interpolation with second XYZ file" << std::endl;
        std::cout << "0.  Exit" << std::endl;
        std::cout << "\nEnter choice: ";
    }
    
    void runCommandLine(int argc, char* argv[]) {
        // Command line mode for specific operations
        if (argc < 3) return;
        
        std::string operation = argv[2];
        
        if (operation == "--swap" && argc >= 4) {
            auto indices = parseIndices(argv[3]);
            if (indices.size() == 2) {
                std::vector<int> idx(indices.begin(), indices.end());
                std::swap(atoms[idx[0]], atoms[idx[1]]);
                printXYZ();
            }
        } else if (operation == "--mirror" && argc >= 4) {
            auto indices = parseIndices(argv[3]);
            if (indices.size() == 3) {
                std::vector<int> idx(indices.begin(), indices.end());
                
                double v1x = atoms[idx[1]].x - atoms[idx[0]].x;
                double v1y = atoms[idx[1]].y - atoms[idx[0]].y;
                double v1z = atoms[idx[1]].z - atoms[idx[0]].z;
                
                double v2x = atoms[idx[2]].x - atoms[idx[0]].x;
                double v2y = atoms[idx[2]].y - atoms[idx[0]].y;
                double v2z = atoms[idx[2]].z - atoms[idx[0]].z;
                
                double a, b, c;
                crossProduct(v1x, v1y, v1z, v2x, v2y, v2z, a, b, c);
                normalize(a, b, c);
                
                double d = -(a * atoms[idx[0]].x + b * atoms[idx[0]].y + c * atoms[idx[0]].z);
                
                for (auto& atom : atoms) {
                    double dist = a * atom.x + b * atom.y + c * atom.z + d;
                    atom.x = atom.x - 2 * dist * a;
                    atom.y = atom.y - 2 * dist * b;
                    atom.z = atom.z - 2 * dist * c;
                }
                
                printXYZ();
            }
        } else if (operation == "--print") {
            printXYZ();
        }
    }
    
    void runInteractive() {
        while (true) {
            showMenu();
            
            int choice;
            std::cin >> choice;
            std::cin.ignore(); // Clear newline
            
            if (atoms.empty() && choice != 0 && choice != 11) {
                std::cout << "Error: No structure loaded. Please load an XYZ file first." << std::endl;
                continue;
            }
            
            switch (choice) {
                case -1: printCurrentStructure(); break;
                case 1: calculateDistanceVector(); break;
                case 2: swapAtoms(); break;
                case 3: calculateBondAngle(); break;
                case 4: calculatePlaneAngle(); break;
                case 5: mirrorThroughPlane(); break;
                case 6: calculateDihedralAngle(); break;
                case 7: calculateGeometricCenter(); break;
                case 8: exportSelectedAtoms(); break;
                case 9: findAtomsWithinRadius(); break;
                case 10: exportCurrentStructure(); break;
                case 11: loadNewFile(); break;
                case 12: toggleUnits(); break;
                case 13: alignWithSecondXYZ(); break;
                case 14: performNEBWithSecondXYZ(); break;
                case 0:
                    std::cout << "Exiting..." << std::endl;
                    return;
                default:
                    std::cout << "Invalid choice. Please try again." << std::endl;
            }
        }
    }
};

int main(int argc, char* argv[]) {
    MoleculeAnalyzer analyzer;
    
    if (argc < 2) {
        std::cout << "Usage: " << argv[0] << " <xyz_file> [options]" << std::endl;
        std::cout << "\nOptions for command-line processing:" << std::endl;
        std::cout << "  --swap <indices>    Swap two atoms and output new XYZ" << std::endl;
        std::cout << "  --mirror <indices>  Mirror through plane defined by 3 atoms" << std::endl;
        std::cout << "  --print             Print current structure to screen" << std::endl;
        std::cout << "\nExample: " << argv[0] << " molecule.xyz --swap 1,3" << std::endl;
        std::cout << "\nIf no options provided, enters interactive mode." << std::endl;
        return 1;
    }
    
    if (!analyzer.loadXYZ(argv[1])) {
        return 1;
    }
    
    if (argc > 2) {
        // Command line mode
        analyzer.runCommandLine(argc, argv);
    } else {
        // Interactive mode
        std::cout << "Loaded " << argv[1] << " successfully." << std::endl;
        analyzer.runInteractive();
    }
    
    return 0;
}